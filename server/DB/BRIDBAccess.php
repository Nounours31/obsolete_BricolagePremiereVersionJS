<?php

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * Description of DBAccess
 *
 * @author PFS
 */
include_once($_SERVER['DOCUMENT_ROOT'].'Bricolage2/server/DB/iBRIDB.php');
include_once($_SERVER['DOCUMENT_ROOT'].'Bricolage2/server/tools/BRILogger.php');
include_once($_SERVER['DOCUMENT_ROOT'].'Bricolage2/server/Envt/BRIEnvt.php');
class BRIDBAccess extends iBRIDB {
    
    function __construct() {
        $this -> _DBName = '[BRIDBAccess]';
        $this -> _logger = new BRILogger($this -> _DBName);
    }

    function __destruct() {
    }

    /**
     * Connectio a la DB en MySQLi
     * @return connexion MySQL vers la DB
     */
    public function connect() {
        $User = BRIEnvt::DBUser;
        $Password = BRIEnvt::DBPassword;
        $BaseName= BRIEnvt::DBBaseName;
        $Port= BRIEnvt::DBPort;
        if (BRIEnvt::isLOCALSERVER) {
            $Host = "127.0.0.1";
        }
        else {
            $Host = BRIEnvt::DBHost;
        }
        $link = mysqli_connect($Host, $User, $Password, $BaseName,$Port);

        if (!$link) {
            $this -> _logger -> fatal("Error: Unable to connect to MySQL.");
            $this -> _logger ->fatal("Debugging errno: " . mysqli_connect_errno());
            $this -> _logger ->fatal("Debugging error: " . mysqli_connect_error());
            echo "Error: Unable to connect to MySQL." . PHP_EOL;
            echo "Debugging errno: " . mysqli_connect_errno() . PHP_EOL;
            echo "Debugging error: " . mysqli_connect_error() . PHP_EOL;
            exit;
        }
        else {
            $this -> _logger ->fatal("DBAccess::Connect Connect, host information: ".mysqli_get_host_info($link));
        }
        return $link;
    }

    /**
     * Close de la connexion SQL
     * @param mysqli $link
     */
    public function close(mysqli $link) {
        $link -> close();
    }

    /**
     * Envoie generique des commande de type : SELECT, SHOW, DESCRIBE or EXPLAIN queries 
     * 
     * @param String $sql la commande SQL 
     * @return Array de array array[i] = la reponse du select pour une occurence
     */
    function selectAsRest ($sql) {
       $link =  $this ->connect();
       $rc = $this->select($link, $sql);
       $this ->close($link);
       return $rc;
    }
    /**
     * Envoie generique des commande de type : SELECT, SHOW, DESCRIBE or EXPLAIN queries 
     * MAIS SANS OUVRIR LA DB --- Permet de regrouper plusiseur call
     * 
     * @param type $link lien vers la DB
     * @param type $sql la reauete SQL
     * @return Array de array array[i] = la reponse du select pour une occurence
     */
    function select ($link, $sql) {
        $this -> _logger ->debug("DBAccess::select SQL[".$sql."]");
        $ret = array();

        $result = $link -> query ($sql);
        if ($result === FALSE) {
            $this -> _logger ->fatal("DBAccess::select error:".$link -> error);
            return $ret;
        }
        if ($result === TRUE)
            return $ret;

        if ($result ->num_rows < 1) {
            $this -> _logger ->debug("DBAccess::select No info in DB:");
            return $ret;
        }

        while ($row = $result->fetch_assoc()) {
            $uneligne = array();
            foreach ($row as $key => $value) {
                $uneligne[$key] = $row[$key];
            }
            $this -> _logger -> debugtab( "DBAccess::select uneligne:", $uneligne);
            array_push($ret, $uneligne);
        }
        $result -> free();
        
        
        // $this -> transfertDBRequest2DBInfoCache($ret);
        return $ret;
    }



    /* INSERT queries */
    function insertAsRest ($sql) {
       $link =  $this ->connect();
       $rc = $this->insert($link, $sql);
       $this ->close($link);
       return $rc;        
    }
    
    function insert ($link, $sql) {
        $this -> _logger ->debug("DBAccess::insert SQL[".$sql."]");

        $result = $link -> query ($sql);
        if ($result === FALSE) {
            $this -> _logger ->fatal("DBAccess::insert error:".$link -> error);
            return FALSE;
        }
        if ($result === TRUE) {
            /* returns the ID generated by a query (usually INSERT) on a table with a column having the AUTO_INCREMENT attribute.
             * If no INSERT or UPDATE statements were sent via this connection, or
             * if the modified table does not have a column with the AUTO_INCREMENT attribute,
             * this function will return zero.*/
            $this -> _logger ->debug("DBAccess::insert ID:".$link -> insert_id);
            $last_id = $link->insert_id;
            return $last_id;
        }
        return TRUE;
    }

        /* UPDATE queries */
    function update ($link, $sql) {
        return $this->_others($link, $sql, true);
    }

    function updateAsRest ($sql) {
        $link =  $this ->connect();
        $rc = $this-> update($link, $sql);
        $this ->close($link);
        return $rc;
    }

    function delete ($link, $sql) {
        return $this->_others($link, $sql, false);
    }

    function deleteAsRest ($sql) {
        $link =  $this ->connect();
        $rc = $this-> delete($link, $sql);
        $this ->close($link);
        return $rc;
    }

    
        /* others queries */
    private function _others ($link, $sql, $updateQuery) {
        if ($updateQuery)
            $this -> _logger ->debug("DBAccess::Upate SQL[".$sql."]");
        else
            $this -> _logger ->debug("DBAccess::Delete SQL[".$sql."]");

        $result = $link -> query ($sql);
        if ($result === FALSE) {
            if ($updateQuery)
                $this -> _logger ->fatal("DBAccess::Update Error:".$link -> error);
            else
                $this -> _logger ->fatal("DBAccess::Delete Error:".$link -> error);
            return FALSE;
        }
        return TRUE;
    }

    /*
    private function transfertDBRequest2DBInfoCache ($DBRequest) {
        if (!is_array($DBRequest))
            throw new Exception ("DB request invalide", 55);

        if ($this->_DBTableKey == null)
            throw new Exception ("DB no primary key defined for this table", 56);
        
        foreach ($DBRequest as $OneRow) {
            $allkeyInrequete = array_keys($OneRow);
            if (in_array($this->_DBTableKey, $allkeyInrequete)) {
                if (!is_array($this->_DBTableInfosCache[$this->_DBTableKey]))
                    $this->_DBTableInfosCache[$this->_DBTableKey] = array();
                
                foreach ($OneRow as $key => $value) {
                    if (strcmp ($key, $this->_DBTableKey) != 0)
                            $this->_DBTableInfosCache[$this->_DBTableKey][$key] = $value;
                }
            }
            else {
                foreach ($OneRow as $key => $value) {
                    $this->_DBTableInfosCache[0][$key] = $value;
                }                
            }
        }
    }*/

}
